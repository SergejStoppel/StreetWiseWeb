### **Phase 4: Finalization & Auditing**

#### **Issue #4.1: Implement Audit Logging**

- **Problem:** For security and diagnostics, we need a record of important actions taken by users.
- **Goal/Benefit:** To have a clear audit trail that can be used for debugging, security analysis, and understanding user behavior while respecting workspace boundaries in our multi-tenant system.
- **Acceptance Requirements:**
    - [ ] An `audit.service.ts` is created with a function like `logAction(userId, workspaceId, action, details)`.
    - [ ] The service supports different log levels: `info`, `warning`, `error`, `security`.
    - [ ] Key events are logged across the application:
        - Authentication: `user.login`, `user.logout`, `user.password_changed`
        - Workspace: `workspace.created`, `workspace.member_added`, `workspace.member_removed`
        - Analysis: `analysis.started`, `analysis.completed`, `analysis.failed`
        - Billing: `subscription.started`, `subscription.canceled`, `credits.purchased`, `credits.consumed`
        - Reports: `report.viewed`, `report.exported`, `report.shared`
        - Security: `auth.failed`, `access.denied`, `rate_limit.exceeded`
    - [ ] Audit logs include: timestamp, user_id, workspace_id, action, details (JSON), IP address, user agent.
    - [ ] A workspace-scoped endpoint `GET /api/workspaces/:id/audit-logs` allows admins to view their logs.
    - [ ] Log retention policies: 90 days for standard logs, 2 years for security/billing logs.
    - [ ] Sensitive data is redacted from logs (passwords, tokens, credit card info).
    - [ ] **Tests:** Unit tests are written to ensure that when the audit service is called, it correctly inserts a record into the database. Integration tests verify workspace-scoped access control.
- **Implementation Details:**
    - Example audit service implementation:
        ```typescript
        export class AuditService {
          async logAction(params: {
            userId: string;
            workspaceId?: string;
            action: string;
            level: 'info' | 'warning' | 'error' | 'security';
            details?: Record<string, any>;
            request?: Request;
          }) {
            const { userId, workspaceId, action, level, details, request } = params;
            
            // Extract request metadata
            const metadata = request ? {
              ip: request.ip || request.headers['x-forwarded-for'],
              userAgent: request.headers['user-agent'],
              method: request.method,
              path: request.path
            } : null;
            
            // Redact sensitive data
            const sanitizedDetails = this.redactSensitiveData(details);
            
            // Insert audit log
            await supabase.from('audit_log').insert({
              user_id: userId,
              workspace_id: workspaceId,
              action,
              level,
              details: sanitizedDetails,
              metadata,
              created_at: new Date().toISOString()
            });
            
            // For security events, also alert admins
            if (level === 'security') {
              await this.alertSecurityTeam(action, sanitizedDetails);
            }
          }
          
          private redactSensitiveData(data: any): any {
            const sensitiveKeys = ['password', 'token', 'api_key', 'credit_card'];
            // Recursively redact sensitive fields
            return deepRedact(data, sensitiveKeys);
          }
        }
        ```
    - Implement audit log streaming for real-time security monitoring.
    - Create database indexes on (workspace_id, created_at) for efficient querying.
    - Consider using a separate audit database/table for performance isolation.
    - Implement log aggregation for security analytics (failed login patterns, etc.).