### **Phase 4: Finalization & Auditing**

#### **Issue #4.3: Implement Database Functions & Triggers**

- **Problem:** Certain database fields, like updated_at timestamps, should be updated automatically. We also need to ensure that when a new user signs up via Supabase Auth, their corresponding profile is created in our public users table. Additionally, we need database-level enforcement of business rules like credit balance checks and workspace quotas.
- **Goal/Benefit:** To automate database maintenance tasks, improve data integrity, enforce business rules at the database level, and seamlessly link the Supabase Auth system with our application's user table.
- **Acceptance Requirements:**
    - [ ] A new SQL migration file (`003_functions_and_triggers.sql`) is created.
    - [ ] A trigger function is created that automatically sets the `updated_at` timestamp to `now()` on any row update.
    - [ ] A trigger is created that fires after a new user is inserted into `auth.users`, creating a corresponding record in `public.users`.
    - [ ] A function to atomically consume credits with balance validation is implemented.
    - [ ] Workspace quota enforcement functions are created (max analyses per month, concurrent analyses).
    - [ ] Cascade deletion triggers ensure data cleanup when workspaces are deleted.
    - [ ] Data retention triggers automatically archive/delete old analyses based on plan type.
    - [ ] Performance impact is measured and triggers are optimized.
    - [ ] **Tests:** Integration tests verify all trigger functionality. Tests confirm that business rules are enforced at the database level.
- **Implementation Details:**
    ```sql
    -- Updated_at trigger function
    CREATE OR REPLACE FUNCTION public.handle_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = now();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Apply updated_at trigger to all relevant tables
    CREATE TRIGGER handle_updated_at BEFORE UPDATE ON workspaces
        FOR EACH ROW EXECUTE FUNCTION handle_updated_at();
    CREATE TRIGGER handle_updated_at BEFORE UPDATE ON websites
        FOR EACH ROW EXECUTE FUNCTION handle_updated_at();
    -- ... repeat for other tables
    
    -- User profile creation on auth signup
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER SECURITY DEFINER AS $$
    DECLARE
        default_workspace_id UUID;
    BEGIN
        -- Create user profile
        INSERT INTO public.users (id, email, full_name)
        VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'full_name');
        
        -- Create default workspace
        INSERT INTO public.workspaces (owner_id, name)
        VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'company_name', 'My Workspace'))
        RETURNING id INTO default_workspace_id;
        
        -- Add user as owner of workspace
        INSERT INTO public.workspace_members (workspace_id, user_id, role)
        VALUES (default_workspace_id, NEW.id, 'owner');
        
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    
    CREATE TRIGGER on_auth_user_created
        AFTER INSERT ON auth.users
        FOR EACH ROW EXECUTE FUNCTION handle_new_user();
    
    -- Credit consumption function with atomic balance check
    CREATE OR REPLACE FUNCTION public.consume_credit(p_workspace_id UUID)
    RETURNS TABLE(success BOOLEAN, balance INTEGER, message TEXT)
    SECURITY DEFINER AS $$
    DECLARE
        current_balance INTEGER;
    BEGIN
        -- Lock the row to prevent race conditions
        SELECT balance INTO current_balance
        FROM report_credits
        WHERE workspace_id = p_workspace_id
        FOR UPDATE;
        
        IF current_balance IS NULL OR current_balance < 1 THEN
            RETURN QUERY SELECT FALSE, COALESCE(current_balance, 0), 'Insufficient credits';
        ELSE
            UPDATE report_credits
            SET balance = balance - 1,
                last_used_at = now()
            WHERE workspace_id = p_workspace_id;
            
            RETURN QUERY SELECT TRUE, current_balance - 1, 'Credit consumed successfully';
        END IF;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Workspace quota enforcement
    CREATE OR REPLACE FUNCTION public.check_analysis_quota(p_workspace_id UUID)
    RETURNS BOOLEAN AS $$
    DECLARE
        plan_limits RECORD;
        current_month_count INTEGER;
        concurrent_count INTEGER;
    BEGIN
        -- Get plan limits
        SELECT p.max_analyses_per_month, p.max_concurrent_analyses
        INTO plan_limits
        FROM subscriptions s
        JOIN plans p ON s.plan_id = p.id
        WHERE s.workspace_id = p_workspace_id
        AND s.status = 'active';
        
        -- Default limits for free plan
        IF NOT FOUND THEN
            plan_limits.max_analyses_per_month := 10;
            plan_limits.max_concurrent_analyses := 1;
        END IF;
        
        -- Check monthly limit
        SELECT COUNT(*) INTO current_month_count
        FROM analyses a
        JOIN websites w ON a.website_id = w.id
        WHERE w.workspace_id = p_workspace_id
        AND a.created_at >= date_trunc('month', CURRENT_DATE);
        
        IF current_month_count >= plan_limits.max_analyses_per_month THEN
            RETURN FALSE;
        END IF;
        
        -- Check concurrent limit
        SELECT COUNT(*) INTO concurrent_count
        FROM analyses a
        JOIN websites w ON a.website_id = w.id
        WHERE w.workspace_id = p_workspace_id
        AND a.status IN ('pending', 'processing');
        
        IF concurrent_count >= plan_limits.max_concurrent_analyses THEN
            RETURN FALSE;
        END IF;
        
        RETURN TRUE;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Data retention based on plan
    CREATE OR REPLACE FUNCTION public.cleanup_old_analyses()
    RETURNS VOID AS $$
    BEGIN
        -- Delete free plan analyses older than 7 days
        DELETE FROM analyses a
        USING websites w
        WHERE a.website_id = w.id
        AND a.created_at < CURRENT_DATE - INTERVAL '7 days'
        AND NOT EXISTS (
            SELECT 1 FROM subscriptions s
            WHERE s.workspace_id = w.workspace_id
            AND s.status = 'active'
        );
        
        -- Archive premium plan analyses older than 90 days
        -- (Implementation depends on archival strategy)
    END;
    $$ LANGUAGE plpgsql;
    ```
    - Schedule cleanup functions using pg_cron or external scheduler.
    - Add database-level constraints for critical business rules.
    - Document all functions and triggers for maintenance.