### **Phase 5: Production Resilience & Scalability**

#### **Issue #5.1: Implement Worker Error Recovery & Dead Letter Queues**

- **Problem:** In a distributed job processing system, failures are inevitable. Without proper error handling, failed jobs could be lost forever, leaving analyses incomplete and customers frustrated.
- **Goal/Benefit:** To create a resilient system that gracefully handles failures, automatically retries transient errors, and provides visibility into persistent failures for manual intervention.
- **Acceptance Requirements:**
    - [ ] All workers implement standardized error handling with categorized error types (transient vs permanent).
    - [ ] BullMQ retry configuration is implemented with exponential backoff (attempts: 3, backoff: exponential).
    - [ ] Dead Letter Queue (DLQ) is configured for each job type after max retries are exhausted.
    - [ ] An admin API endpoint `GET /api/admin/failed-jobs` is created to list DLQ jobs (protected by admin role).
    - [ ] An admin API endpoint `POST /api/admin/failed-jobs/:jobId/retry` is created to manually retry failed jobs.
    - [ ] Workspace-based access control ensures admins can only see/retry jobs for their workspace.
    - [ ] Alerting is configured to notify admins when DLQ size exceeds threshold (e.g., 10 jobs).
    - [ ] **Tests:** Unit tests verify retry logic with mocked failures. Integration tests verify DLQ behavior and admin endpoints respect workspace boundaries.
- **Implementation Details:**
    ```typescript
    // Example retry configuration
    const jobOptions = {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000, // Start with 2 second delay
      },
      removeOnComplete: true,
      removeOnFail: false, // Keep failed jobs for DLQ
    };
    
    // Error categorization
    class TransientError extends Error {} // Retry
    class PermanentError extends Error {} // Don't retry
    
    // Workspace isolation for DLQ queries
    const failedJobs = await queue.getFailed();
    const workspaceJobs = failedJobs.filter(job => 
      job.data.workspaceId === requestingWorkspaceId
    );
    ```
    - Use BullMQ's built-in DLQ functionality with the `failed` event handler.
    - Implement structured error logging with correlation IDs for tracing.
    - Consider implementing circuit breakers for external services (Puppeteer, OpenAI).
    - Store error context in job data for debugging (stack trace, attempt number, timestamp).