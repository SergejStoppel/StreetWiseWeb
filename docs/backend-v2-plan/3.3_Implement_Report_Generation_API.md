### **Phase 3: Billing & Reporting**

#### **Issue #3.3: Implement Report Generation API**

- **Problem:** The frontend needs an endpoint to fetch the data for both free and detailed reports.
- **Goal/Benefit:** A secure and efficient API that provides the frontend with all the necessary data to render reports while enforcing entitlement rules and workspace boundaries.
- **Acceptance Requirements:**
    - [ ] A protected endpoint `GET /api/reports/:analysis_id?type=<free|detailed>` is created.
    - [ ] Workspace ownership validation ensures users can only access reports for analyses in their workspace.
    - [ ] If `type=detailed` is requested, the controller first checks for entitlement (active subscription OR `report_credits.balance > 0`).
    - [ ] If not entitled, it returns `402 Payment Required` with details about purchasing options.
    - [ ] If entitled via credits, the `report_credits` balance is decremented atomically (preventing race conditions).
    - [ ] The controller fetches the relevant issues from the `*_issues` tables based on the report type.
    - [ ] Free reports include: critical issues only, basic metrics, limited recommendations.
    - [ ] Detailed reports include: all issues, comprehensive metrics, AI summaries, actionable recommendations, export options.
    - [ ] Report access is logged in `audit_log` for security and usage tracking.
    - [ ] Response includes report metadata (generated_at, expires_at, report_version).
    - [ ] **Tests:** Integration tests are written for all entitlement scenarios: free user getting a free report (success), free user getting a detailed report (fail), credit user getting a detailed report (success, credit consumed), and subscribed user getting a detailed report (success, no credit consumed).
- **Implementation Details:**
    - The logic for checking entitlement and consuming a credit should be atomic:
        ```typescript
        async function checkAndConsumeEntitlement(workspaceId: string, reportType: string): Promise<EntitlementResult> {
          if (reportType === 'free') {
            return { entitled: true, method: 'free' };
          }
          
          // Start transaction
          const { data: subscription } = await supabase
            .from('subscriptions')
            .select('status')
            .eq('workspace_id', workspaceId)
            .eq('status', 'active')
            .single();
            
          if (subscription) {
            return { entitled: true, method: 'subscription' };
          }
          
          // Check and consume credit atomically
          const { data: credit, error } = await supabase.rpc('consume_credit', {
            p_workspace_id: workspaceId
          });
          
          if (error || !credit.success) {
            return { entitled: false, method: null, remainingCredits: credit?.balance || 0 };
          }
          
          return { entitled: true, method: 'credit', remainingCredits: credit.balance };
        }
        ```
    - The controller will need to query across multiple tables and assemble the final response:
        ```typescript
        interface ReportResponse {
          analysis: AnalysisData;
          issues: {
            accessibility: AccessibilityIssue[];
            seo: SeoIssue[];
            performance: PerformanceIssue[];
          };
          summary: {
            totalIssues: number;
            criticalIssues: number;
            score: number;
            aiInsights?: string; // Only in detailed reports
          };
          metadata: {
            reportType: 'free' | 'detailed';
            generatedAt: string;
            expiresAt: string;
            reportVersion: string;
            entitlementMethod: 'free' | 'subscription' | 'credit';
            remainingCredits?: number;
          };
        }
        ```
    - Implement report caching (Redis) for recently generated reports.
    - Add export endpoints: `GET /api/reports/:analysis_id/export/pdf` and `/export/csv`.
    - Implement report versioning to handle schema changes gracefully.